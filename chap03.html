<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.475">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>HEMP Using R - 3&nbsp; 일반화가능도 이론</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./chap04.html" rel="next">
<link href="./chap02.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">일반화가능도 이론</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">HEMP Using R</a> 
        <div class="sidebar-tools-main">
    <a href="./HEMP-Using-R.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">머리말</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap01.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">R 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap02.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">고전검사이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap03.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">일반화가능도 이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap04.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">측정에서 요인분석적 접근</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap05.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">이분 문항반응이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap06.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">다분 문항반응이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap07.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">다차원 문항반응이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap08.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">설명적 문항반응이론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap09.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">데이터 시각화 및 측정 모델</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap10.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">동등화</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap11.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">측정 불변성과 차별기능문항</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chap12.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">측정의 고급 주제</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#개요" id="toc-개요" class="nav-link active" data-scroll-target="#개요"><span class="toc-section-number">3.1</span>  개요</a></li>
  <li><a href="#소개" id="toc-소개" class="nav-link" data-scroll-target="#소개"><span class="toc-section-number">3.2</span>  소개</a></li>
  <li><a href="#예제" id="toc-예제" class="nav-link" data-scroll-target="#예제"><span class="toc-section-number">3.3</span>  예제</a>
  <ul class="collapse">
  <li><a href="#단일국면-설계" id="toc-단일국면-설계" class="nav-link" data-scroll-target="#단일국면-설계"><span class="toc-section-number">3.3.1</span>  단일국면 설계</a></li>
  <li><a href="#국면-교차-설계" id="toc-국면-교차-설계" class="nav-link" data-scroll-target="#국면-교차-설계"><span class="toc-section-number">3.3.2</span>  2국면 교차 설계</a></li>
  <li><a href="#국면-부분-내재-설계" id="toc-국면-부분-내재-설계" class="nav-link" data-scroll-target="#국면-부분-내재-설계"><span class="toc-section-number">3.3.3</span>  2국면 부분 내재 설계</a></li>
  <li><a href="#고정-국면을-가진-2국면-교차-설계" id="toc-고정-국면을-가진-2국면-교차-설계" class="nav-link" data-scroll-target="#고정-국면을-가진-2국면-교차-설계"><span class="toc-section-number">3.3.4</span>  고정 국면을 가진 2국면 교차 설계</a></li>
  </ul></li>
  <li><a href="#요약" id="toc-요약" class="nav-link" data-scroll-target="#요약"><span class="toc-section-number">3.4</span>  요약</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">일반화가능도 이론</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="개요" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="개요"><span class="header-section-number">3.1</span> 개요</h2>
<p>이 장에서는 일반화가능도 이론을 소개하는데, 문헌에서는 G 이론이라고도 합니다. 이 장에서는 G 이론에 대한 간략한 검토로 시작하여 G 이론의 핵심 개념, 특히 일반화 가능도 연구(G 연구)와 결정 연구(D 연구)의 구분, 국면(facets)과 측정 단위, 연구 설계, 고정 국면 무선 국면에 대해 정의합니다. 다양한 설계에 대해 R을 사용하여 G 및 D 연구를 실행하는 방법을 hemp 및 lme4(Bates, Mächler, Bolker, &amp;Walker, 2015) 패키지를 사용하는 몇 가지 예제를 통해 보여드립니다.</p>
</section>
<section id="소개" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="소개"><span class="header-section-number">3.2</span> 소개</h2>
<p>측정에서 우리의 주요 관심사는 구인 또는 잠재 변수에 대한 개인의 기저에 있는 진점수를 추정하는 데 있습니다. 예를 들어, 피험자의 대수 지식, 지능 지수, 집행 기능 기술 또는 삶의 질을 추정하는 데 관심이 있을 수 있습니다. 안타깝게도 이러한 모든 추정치는 최선의 노력에도 불구하고 불완전하고 일정 수준의 측정 오차를 포함할 수밖에 없습니다.</p>
<p>측정 과정에서 피할 수 없는 이러한 오차를 조정하기 위해 다양한 모델이 제안되었습니다. 제2장에서는 가장 간단하고 실제로 가장 일반적으로 적용되는 모델인 고전적 검사 이론(CTT) 모델을 소개했습니다. CTT 모델에서는 하나의 구인에 대한 개인의 관찰 점수가 해당 구인에 대한 진점수와 오차의 합이고(방정식 3.1의 첫 번째 줄), 따라서 검사 점수의 관찰 분산은 진점수 분산과 잔차(즉, 오차) 분산(방정식 3.1의 두 번째 줄, 자세한 내용은 2장 참조)의 합이라고 가정한다는 점을 기억하시기 바랍니다. 수학적으로 CTT 모델을 다음과 같이 정의할 수 있습니다.</p>
<p><span class="math display">\[
X=T+E
\]</span>, and</p>
<p><span class="math display">\[
\sigma_X^2 = \sigma_T^2 + \sigma_E^2
\]</span></p>
<p>CTT 모델에서는 진점수 분산에 기인할 수 없는 관찰된 모든 분산 원인이 단일 잔차 항으로 포착됩니다. 따라서 다양한 오차 원인을 구분하고 정량화하려는 시도는 하지 않습니다. 오차 분산에 포함된 모든 오차 원인은 가변성 여부, 즉 검사 개발자/관리자의 통제 범위 내에 있는지 여부와 가변성이 없는지에 관계없이 동일한 방식으로 처리됩니다.</p>
<p>일반화 가능도 이론(G 이론)에서 우리의 주요 초점은 오차 분산을 통제 가능한 변산의 원인으로 분리하는 것입니다(Shavelson &amp; Webb, 1991). 우리는 이 분산을 실무자와 연구자가 조작할 수 있는 측정 조건(국면(facets)이라고 함) 및 측정 단위(일반적으로 학생 또는 연구 참여자)와 관련된 변산원으로 분리할 수 있기를 원합니다. 오차를 다양한 원인으로 세분화하면 국면의 수준을 변경하는 것이 시험 점수의 신뢰도에 어떤 영향을 미치는지 정량화할 수 있으며, 그에 따라 검도구를 조정할 수 있습니다.</p>
<p>구체적인 예로 대학원 준비도를 측정하는 도구를 만든다고 상상해 봅니다. 대학원 프로그램은 학생들이 연구 논문, 원고, 기술 보고서 등을 통해 자신의 아이디어를 발표할 수 있는 연구자가 될 수 있도록 교육합니다. 따라서 지원자는 대학원 지원 및 입학 시 논리적이고 명료한 에세이를 작성할 수 있는 탄탄한 글쓰기 능력을 갖춰야 합니다. 대학원에서 필수적인 작문 능력을 측정하기 위해 지원자가 응답해야 하는 일련의 작문 프롬프트로 구성된 검사도구를 구성합니다. 검사도구에 선택한 쓰기 프롬프트는 우리가 관심을 갖는 모든 쓰기 프롬프트를 나타낼 수 있으며(즉, 고정된 수의 쓰기 프롬프트가 있습니다), 쓰기 프롬프트는 고정국면이라고 할 수 있습니다. 이는 분산분석의 고정 효과와 유사합니다. 쓰기 프롬프트는 우리가 선택할 수 있는 매우 크고 잠재적으로 무한한 쓰기 프롬프트 풀에서 무작위로 추출한 샘플일 가능성이 높습니다. 분산분석의 맥락에서 쓰기 프롬프트는 무선효과로 취급되며 쓰기 프롬프트는 무선 국면라고 할 수 있습니다.</p>
<p>검사도구를 구성한 후에는 피험자(즉, 예비 대학원생)을 대상으로 평가를 실시합니다. 예비 대학원생에게는 한 시간 동안 글쓰기 프롬프트에 대한 응답을 작성할 시간이 주어집니다. 그런 다음 채점자가 답변을 채점합니다. 작문 프롬프트와 마찬가지로, 우리는 일반적으로 특정 채점자가 아니라 모든 채점자에게 관심이 있으므로 채점자를 무작위적인 측면으로 간주합니다. 채점자가 모든 쓰기 프롬프트에 점수를 매길 수 있다면 쓰기 프롬프트와 채점자는 교차된 것으로 간주되지만, 채점자가 쓰기 프롬프트의 특정 하위 집합에만 점수를 매길 수 있다면 채점자는 쓰기 프롬프트 내에 내재된 것으로 간주됩니다. 이 예에서는 모든 채점자가 모든 쓰기 프롬프트에 점수를 매길 수 있으므로 채점자와 쓰기 프롬프트가 교차한다고 가정합니다.</p>
<p>우리가 달성하고자 하는 것은 모든 쓰기 프롬프트와 모든 채점자에 걸쳐 학생의 실제 쓰기 능력을 추정하는 것입니다. 즉, G 이론에서 우리의 목표는 모든 잠재적 변인들에 대해 일반화 가능하고 신뢰할 수 있는 작문 능력의 추정치를 얻는 것입니다(Brennan, 1992). 이 가상의 예에서 학생, 쓰기 프롬프트 및 평가자는 모두 변산원을 나타내며, 쓰기 프롬프트와 평가자는 국면을 나타내고 학생은 측정 단위를 나타냅니다. 학생과 관련된 변산은 진점수 분산 또는 G 이론 용어로 전집 점수 분산이 될 것입니다.</p>
<p>단일 채점자(r)에 의해, 단일 쓰기 프롬프트(w)에서 학생(들)에 대해 관찰된 점수 <span class="math inline">\(X_{swr}\)</span> 는 다음과 같이 분해할 수 있습니다:</p>
<p><span class="math display">\[
X_{swr}=\mu+\nu_s+\nu_w+\nu_r+\nu_{sw}+\nu_{sr}+\nu_{wr}+\nu_{swr},e.
\]</span></p>
<p>방정식 3.2에서 학생의 점수는 총평균(<span class="math inline">\(mu\)</span>), 학생 효과(<span class="math inline">\(\nu_s\)</span>), 쓰기 프롬프트 효과(<span class="math inline">\(\nu_w\)</span>), 채점자 효과(<span class="math inline">\(\nu_r\)</span>), 학생별 쓰기 프롬프트 효과(<span class="math inline">\(\nu_{sw}\)</span>), 채점자별 학생 효과(<span class="math inline">\(\nu_{sr}\)</span>), 채점자별 쓰기 프롬프트 효과(<span class="math inline">\(\nu_{wr}\)</span>), 마지막으로 잔차 항(<span class="math inline">\(\nu_{swr,e}\)</span>)과 완전히 섞여있는 채점자별 쓰기프롬프트별 학생 효과라는 8개의 구성 요소를 포함하고 있습니다. 이러한 각 효과는 무선 효과(확률 변수)라고 가정하기 때문에 일반적으로 평균이 0이고 분산은 알 수 없는 정규 분포(상수인 총평균 제외)로 가정하는 분포를 갖습니다. 또한 이 설계에서 전집(즉, 가능한 모든 문항과 채점자) 및 모집단(즉, 모든 학생)에 걸쳐 작문 프롬프트에서 관찰된 점수의 총 분산은 다음과 같이 표현할 수 있습니다:</p>
<p><span class="math display">\[
X^2_{swr}=\sigma^2_s+\sigma^2_w+\sigma^2_r+\sigma^2_{sw}+\sigma^2_{sr}+\sigma^2_{wr}+\sigma^2_{swr},e.
\]</span></p>
<p>방정식 3.3에서 관찰된 점수의 분산은 7개의 독립 분산으로 쓸 수 있음을 알 수 있습니다: 학생의 쓰기 능력의 분산은 G 이론에서 전집 점수 분산으로 알려져 있으며, 이는 CTT의 진점수 분산(<span class="math inline">\(\sigma^2_s\)</span>)과 유사합니다; 쓰기 프롬프트의 분산(예: <span class="math inline">\(\sigma^2_w\)</span>, 일부 프롬프트가 다른 프롬프트보다 응답하기가 더 쉬울 수 있는 정도); 채점자의 분산(<span class="math inline">\(\sigma^2_r\)</span>, 일부 채점자가 다른 채점자보다 더 높거나 낮은 점수를 주는 정도); 학생별 쓰기 프롬프트의 분산(<span class="math inline">\(\sigma^2_{sw}\)</span>, 일부 쓰기 프롬프트가 다른 학생보다 더 쉽게 답할 수 있는 정도); 학생별 채점자 분산(<span class="math inline">\(\sigma^2_{sr}\)</span>, 채점자가 특정 학생에게 다른 학생보다 높은 점수를 부여하는 정도); 채점자별 쓰기 프롬프트 분산(<span class="math inline">\(\sigma^2_{wr}\)</span>, 채점자가 일부 프롬프트에 다른 채점자보다 높은 점수를 주는 정도), 마지막으로 학생별 쓰기 프롬프트별 채점자 분산(<span class="math inline">\(\sigma^2_{swr},e\)</span>, 특정 평가자가 특정 프롬프트에서 학생이 더 높은 점수를 받는 정도)은 잔차 분산과 완전히 섞입니다. CTT에서는 분산인 <span class="math inline">\(\sigma^2_w...\sigma^2_{swr,e}\)</span>가 모두 단일 잔차 분산인 <span class="math inline">\(\sigma^2_E\)</span>로 포착됩니다.</p>
<p>그림 3.1은 위에서 설명한 가상의 설계에 대한 벤 다이어그램을 보여줍니다. 그림 3.1에는 학생, 쓰기 프롬프트, 채점자 및 이들의 상호 작용과 관련된 변산원이 나와 있습니다. 원 사이의 겹치는 부분(변산원)은 상호작용의 크기를 나타냅니다.</p>
<p>이 시점에서 CTT에 비해 G 이론의 장점이 더욱 분명해집니다. 총 변동을 조작 가능한 국면으로 분해하면 각 측정 조건과 관련된 변산의 양을 정량화할 수 있으며, 특정 수준의 신뢰도를 얻기 위해 각 조건과 관련된 레벨의 수를 변경할 수 있습니다.</p>
<p>G 이론에서는 일반적으로 일반화 가능도(G) 연구와 결정(D) 연구라는 두 가지 유형의 연구가 수행됩니다(Shavelson &amp; Webb, 1991). G 연구에서는 모든 잠재적인 변산원을 파악하고 이를 연구 설계에 통합하여 허용 가능한 관찰 전집을 정의합니다. 쓰기 프롬프트 예시에서는 모든 채점자가 모든 쓰기 프롬프트를 채점할 수 있으므로, 허용 가능한 관찰 전집은 프롬프트와 채점자의 모든 조합이 허용 가능하다는 것입니다. G 연구에서는 방정식 3.3과 그림 3.1에 표시된 분산을 추정합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_31.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">2국면 교차설계. s는 학생(측정 단위), w는 쓰기 프롬프트, r은 채점자, e는 오차임</figcaption><p></p>
</figure>
</div>
<p>D 연구에서는 일반화 가능하고 신뢰할 수 있는 점수를 얻기 위해 가상의 시나리오를 조사합니다. 쓰기 프롬프트 예시에서는 프롬프트 수, 채점자 수 또는 둘 다를 변경할 수 있다고 가정할 수 있습니다. G 및 D 연구를 주로 안내하는 것은 검사 점수를 어떻게 사용할 계획인지입니다. 예비 대학원생의 상대적 순위 결정과 같은 상대적인 결정을 내리는 데 검사 점수를 사용하려는 경우, CTT의 신뢰도에 해당하는 G 이론인 일반화 가능도 계수를 사용하여 점수를 요약합니다. 검사 점수를 사용하여 학생이 대학원 수준에서 글을 쓸 준비가 되었는지 여부와 같은 절대적인 결정을 내리려면 의존도 계수를 사용하여 점수를 요약합니다. 일반화 가능도 계수를 구하려면 상대 오차 분산인 <span class="math inline">\(\sigma^2_{rel}\)</span>을 계산해야 하고, 의존도 계수를 구하려면 절대 오차 분산인 <span class="math inline">\(\sigma^2_{abs}\)</span>를 계산해야 합니다. 그러면 일반화 가능도 계수와 의존도 계수는 다음과 같이 계산됩니다:</p>
<p><span class="math display">\[
일반화가능도 계수=\rho^2={\sigma^2_s \over \sigma^2_S + \sigma^2_{rel}}
\]</span></p>
<p><span class="math display">\[
의존도 계수 = \phi= {\sigma^2_s \over \sigma^2_S + \sigma^2_{abs}}
\]</span></p>
<p>여기서 <span class="math inline">\(\sigma^2_s\)</span> 분산은 학생의 검사 점수 변산(전집 점수 분산)입니다. <span class="math inline">\(\sigma^2_{rel}\)</span>과 <span class="math inline">\(\sigma^2_{abs}\)</span>에 들어가는 것은 연구 설계에 따라 다릅니다. 이러한 분산 구성 요소에 대해 더 자세히 알고 싶은 독자, 그리고 더 일반적으로 G 및 D 연구에 대해 더 알고 싶은 독자에게는 <em>일반화 가능도 이론: 입문서</em>를 강력히 추천합니다(Shavelson and Webb, 1991). 이 입문서는 따라 하기 쉽고, 다양한 G 연구 설계를 안내하며, 관심 있는 독자가 적절한 연구 설계를 결정하는 데 도움을 줄 수 있습니다.</p>
<p>다음 섹션에서는 다양한 연구 설계에 대해 설명하고, hemp 패키지의 gstudy 및 dstudy 함수를 사용하여 이러한 설계의 일반화 가능도 및 의존도 계수를 계산하는 방법을 보여줍니다.</p>
</section>
<section id="예제" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="예제"><span class="header-section-number">3.3</span> 예제</h2>
<section id="단일국면-설계" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="단일국면-설계"><span class="header-section-number">3.3.1</span> 단일국면 설계</h3>
<p>첫 번째 예시 데이터는 30명의 연구 참여자 그룹을 대상으로 실시한 가상의 집행 기능(EF) 검사도구에서 가져온 것입니다. 이 검사도구는 참가자의 집행기능 능력을 측정하는 이분법적으로 채점된 10개의 문항으로 구성되어 있습니다. efData 데이터 세트는 hemp 패키지에서 사용할 수 있습니다. 이 예에서는 단일국면인 문항(문항)과 측정 단위인 참가자(참가자)가 있습니다. 따라서 이것은 단일 국면(p x i) 설계의 예입니다.</p>
<p>efData 내의 변수 Score에는 참가자가 제공한 문항에 대한 응답이 포함됩니다. 우리는 시행된 문항에 특별히 관심이 있는 것이 아니라 모든 잠재적 문항에 관심이 있기 때문에 이 국면을 무선으로 간주합니다. 일반적으로 국면을 고정된 것으로 취급해야 하는 특별한 이유가 없는 한 국면을 무선으로 취급하는 것이 좋습니다. 그림 3.2는 이 설계에서 변산원을 보여 주며, 집행 기능에서 관찰된 총 점수의 변산은 다음과 같이 작성할 수 있습니다:</p>
<p><span class="math display">\[
\sigma^2(X_{pi})=\sigma^2_p+\sigma^2_i+\sigma^2_{pi,e.}
\]</span></p>
<p>그림 3.2와 방정식 3.6을 보면 연구에는 참가자 관련 변산(p), 문항 관련 변산(i), 문항과 참가자 간의 상호작용 관련 변산(pi,e)의 세 가지 변산원이 있음을 알 수 있습니다. 단일국면 설계에서는 이러한 상호 작용이 무선오차와 완전히 섞여있습니다(Shavelson &amp; Webb, 1991).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_32.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">단일국면설계(p*i). p는 참가자(측정 단위), i는 문항, e는 오차임</figcaption><p></p>
</figure>
</div>
<section id="g-연구" class="level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1" class="anchored" data-anchor-id="g-연구"><span class="header-section-number">3.3.1.1</span> G 연구</h4>
<p>G 연구에서는 방정식 3.6에 정의된 분산 성분을 추정합니다. 이러한 분산 성분을 추정하기 위해 먼저 라이브러리 명령을 사용하여 hemp 패키지를 로드합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(hemp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: psych</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: lattice</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: lavaan</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>This is lavaan 0.6-16
lavaan is FREE software! Please report any bugs.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'lavaan'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:psych':

    cor2cov</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: mirt</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: stats4</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: lme4</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: Matrix</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'lme4'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:mirt':

    fixef</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: reshape2</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: boot</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'boot'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:lattice':

    melanoma</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:psych':

    logit</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: equate</code></pre>
</div>
</div>
<p>hemp 패키지는 lme4 패키지의 lmer 함수를 사용하여 분산 성분을 추정합니다. 참가자 및 문항 분산을 추정하려면 무선 효과를 지정하기 위해 lme4의 구문을 사용해야 합니다. 이러한 효과에 대한 lme4 구문은 각각 (1 | Participants) 및 (1 | Items)입니다. 동일한 구문 내에서 Score는 분해하려는 종속 변수 역할을 합니다. lme4에 모델을 맞추고 결과를 onefacet_mod로 저장한 후, 모델에서 gstudy 함수를 호출합니다(즉, onefacet_mod). G 연구를 onefacet으로 저장한 다음 마지막에 결과를 출력합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>onefacet_mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Score <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> Participants) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Items),</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">data =</span> efData)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>onefacet <span class="ot">&lt;-</span> <span class="fu">gstudy</span>(onefacet_mod)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>onefacet</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        Source Est.Variance Percent.Variance
1 Participants       0.0258             9.9%
2        Items       0.0959            36.8%
3     Residual       0.1387            53.3%</code></pre>
</div>
</div>
<p>G 연구에서 추정된 분산은 단일 EF 문항에 대한 참가자의 점수를 전집 점수로 일반화할 때 발생하는 오차의 크기를 반영합니다. 이는 현재 검사 길이인 10개 문항을 기준으로 일반화할 때 발생하는 분산이 아닙니다. 이를 알고 싶다면, 의심할 여지 없이, D 연구를 수행할 때 10개의 문항으로 구성된 검사를 고려해야 합니다.</p>
<p>G 연구에서 추정된 분산을 해석하는 데 유용한 휴리스틱(어림짐작)은 각 분산 구성 요소가 전체 분산에서 차지하는 비율을 계산하는 것입니다.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 이 비율은 위의 결과 데이터 프레임의 마지막 열에 나와 있습니다. 단일 문항 검사의 경우, 참가자의 분산 성분(즉, 전집 점수 분산)이 전체 분산에서 차지하는 비중이 10%에 불과하다는 것을 알 수 있습니다. 이는 다소 낮은 수치로, 당연히 단일 문항 검사의 신뢰도가 높지 않음을 시사합니다.</p>
<p>전집 점수 구성 요소의 해석을 돕기 위해 히스토그램을 만들 수 있습니다. 아래에 제시된 R 코드는 lattice 패키지를 로드하고 aggregate 함수를 사용하여 각 참가자가 정답을 맞힌 문항의 비율을 계산한 다음 히스토그램을 생성합니다(그림 3.3 참조).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_33.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">EF 검사도구에서 정답을 맞힌 문항의 비율</figcaption><p></p>
</figure>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"lattice"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>scores <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(efData<span class="sc">$</span>Score, <span class="at">by =</span> <span class="fu">list</span>(efData<span class="sc">$</span>Participants), mean)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">histogram</span>(<span class="sc">~</span> x, scores, <span class="at">type =</span> <span class="st">"count"</span>, <span class="at">xlab =</span> <span class="st">"Proportion of Items Correct"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="chap03_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>히스토그램을 보면 모든 문항을 정답 또는 오답으로 맞힌 참가자는 한 명도 없으며, 압도적으로 많은 참가자가 시험에서 50% 또는 60%의 문항(즉, 정답이 5개 또는 6개)을 정답으로 맞힌 것을 알 수 있습니다. 이렇게 촘촘한 클러스터링으로 인해 전집 점수 분산이 낮았습니다.</p>
<p>문항의 분산 성분(0.0959 또는 전체 분산의 36.8%)은 전집 점수 분산에 비해 크지만 잔차 분산에 비해서는 작습니다. Shavelson과 Webb(1991)은 이 분산의 제곱근을 구하여 표준 편차를 구한 다음 4개의 표준 편차(정규 분포를 가정할 경우 점수의 약 95%)에 대한 범위를 계산할 것을 제안합니다. 표준 편차는 약 0.31이며 여기에 4를 곱하면 약 1.2가 됩니다. 문항 평균의 범위가 0에서 1까지만 가능하다는 점을 감안할 때 표준편차가 0.31이라는 것은 문항의 평균에 변산이 많다는 것을 의미합니다.</p>
<p>다음으로 aggregate 함수를 사용하여 각 문항의 평균을 다시 계산하고 문항 평균을 item_means로 저장합니다. 결과를 출력하기 전에 colnames 함수를 사용하여 이 새 데이터 집합의 열 이름을 “Item” 및 “Mean”으로 바꿉니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>item_means <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(efData<span class="sc">$</span>Score, <span class="at">by =</span> <span class="fu">list</span>(efData<span class="sc">$</span>Items), mean)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(item_means) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Item"</span>, <span class="st">"Mean"</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>item_means</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Item       Mean
1     1 0.94285714
2     2 0.68571429
3     3 0.68571429
4     4 0.08571429
5     5 0.74285714
6     6 0.77142857
7     7 0.08571429
8     8 0.60000000
9     9 0.45714286
10   10 0.11428571</code></pre>
</div>
</div>
<p>문항 평균의 범위는 0.09에서 94로 상당히 큰 변산을 보이며, 문항이 설명하는 높은 변산 비율을 입증합니다.</p>
<p>잔차 분산이 크다는 것은 참가자와 문항의 상호 작용과 무선 오차(우리가 풀 수 없는)를 모두 포착한 것입니다. 일부 참가자가 일부 문항에 더 쉽게 답했거나, (평가가 실시된 물리적 환경 또는 실내 온도와 같은) 시스템적 변산이 있었을 수도 있고, (일부 참가자가 평가를 완료할 때 배가 고프거나 피곤한 상태였다는 등) 무작위적인 변산이 있었을 수도 있습니다. 어느 쪽이든, 우리는 이 분산 구성 요소에서 이러한 소스를 서로 분리할 수 없습니다.</p>
<p>G 연구에서 EF에 대한 단일 문항 검사는 신뢰성이 높지 않다는 결론을 내릴 수 있으며, 이는 놀라운 결과가 아닙니다. 다음에는 오차를 줄이고 점수의 신뢰도를 높이기 위해 검사의 길이를 다양하게 하는 것을 고려할 수 있습니다. 이는 D 연구에서 검토할 수 있습니다.</p>
</section>
<section id="d-연구" class="level4" data-number="3.3.1.2">
<h4 data-number="3.3.1.2" class="anchored" data-anchor-id="d-연구"><span class="header-section-number">3.3.1.2</span> D 연구</h4>
<p>EF 평가에는 국면(문항)이 하나만 있습니다. 따라서 일반화 가능도 또는 의존도 계수에 영향을 미치기 위해 EF 평가에 표시되는 문항의 수만 변경할 수 있습니다. D 연구는 hemp 패키지의 dstudy 함수를 사용하여 수행할 수 있습니다. 단일 문항 EF 검사의 신뢰도를 계산하려는 경우 다음과 같이 수행합니다:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy</span>(onefacet, <span class="at">unit =</span> <span class="st">"Participants"</span>, <span class="at">n =</span> <span class="fu">c</span>(<span class="st">"Items"</span> <span class="ot">=</span> <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        Source Est.Variance   N Ratio of Var:N
1 Participants       0.0258 350         0.0258
2        Items       0.0959   1         0.0959
3     Residual       0.1387   1         0.1387

The generalizability coefficient is: 0.1568389.
The dependability coefficient is: 0.09907834.</code></pre>
</div>
</div>
<p>hemp 패키지에서 dstudy 함수를 호출하면 기본적으로 세 가지 정보가 출력됩니다:</p>
<ol type="1">
<li>분산 소스, 추정된 분산, 참여자 및 국면의 수준 수, 이 분산을 국면의 수준 수로 나눈 값이 포함된 데이터 프레임,</li>
<li>일반화 가능도 계수, 그리고</li>
<li>의존도 계수.</li>
</ol>
<p>D 연구에 따르면 하나의 문항으로만 구성된 검사의 일반화 가능도 계수는 약 .16, 의존도 계수는 .10입니다. 현재 검사 길이가 10이므로 10개 문항으로 구성된 검사 길이에 대한 신뢰도를 알고 싶습니다. dstudy 함수에서 “n” 인수를 n = c(“Items” = 10)로 변경합니다. 결과를 onefacet_dstudy로 저장합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>onefacet_dstudy <span class="ot">&lt;-</span> <span class="fu">dstudy</span>(onefacet, <span class="at">unit =</span> <span class="st">"Participants"</span>, <span class="at">n =</span> <span class="fu">c</span>(<span class="st">"Items"</span> <span class="ot">=</span> <span class="dv">10</span>))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>onefacet_dstudy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        Source Est.Variance   N Ratio of Var:N
1 Participants       0.0258 350        0.02580
2        Items       0.0959  10        0.00959
3     Residual       0.1387  10        0.01387

The generalizability coefficient is: 0.6503655.
The dependability coefficient is: 0.5237515.</code></pre>
</div>
</div>
<p>현재 검사 길이로 일반화 가능도 계수는 .65, 의존도 계수는 .52입니다. 이러한 신뢰도는 여전히 매우 낮으므로 점수의 신뢰도를 개선하려면 검사 길이를 더 늘려야 합니다.</p>
<p>dstudy 함수의 출력을 onefacet_dstudy로 저장했음을 기억하십시오. onefacet_dstudy에 저장된 결과를 사용하여 상대 오차 분산(relvar)과 절대 오차 분산(absvar)을 추출할 수 있습니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>onefacet_dstudy<span class="sc">$</span>relvar</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.01387</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>onefacet_dstudy<span class="sc">$</span>absvar</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.02346</code></pre>
</div>
</div>
<p>검사 길이 증가가 신뢰도에 미치는 영향을 시각화하는 효과적인 방법은 검사 길이에 대한 계수를 그래프로 그리는 것입니다. 이 작업은 신뢰도를 계산할 검사 길이의 값 범위를 지정하여 dstudy_plot을 사용하여 수행할 수 있습니다. 아래 호출에서는 다양한 검사 길이(예: 10개 항목에서 60개 항목)에 대해 의존도 계수(g_coef = FALSE 인수를 통해 지정됨)를 플롯합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy_plot</span>(onefacet, <span class="at">unit =</span> <span class="st">"Participants"</span>, <span class="at">facets =</span> <span class="fu">list</span>(<span class="at">Items =</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">60</span>)), <span class="at">g_coef =</span> <span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="chap03_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>그림 3.4에서는 현재 검사의 문항 수를 10개에서 20개로 두 배로 늘릴 때 신뢰도가 가장 크게 향상되는 것을 볼 수 있습니다. 검사 점수의 용도에 따라(예: 고부담인지 저부담의 절대 결정인지) 40개 문항의 검사 길이에 대해 .80 미만의 신뢰도로 만족할 수도 있고, 더 높은 신뢰도가 필요한 경우(예: .90의 신뢰도) 현재 검사보다 6배 더 긴 검사(즉, 60개 문항)가 필요할 수 있습니다. 신뢰도 계수에 대한 다양한 D 연구 그래프의 유용성은 국면의 수준 수를 늘리는 것이 신뢰도에 미치는 영향을 신속하게 평가할 수 있다는 것입니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_34.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">단일국면 무선 설계에 대한 EF 항목 수에 대한 의존도 계수</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="국면-교차-설계" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="국면-교차-설계"><span class="header-section-number">3.3.2</span> 2국면 교차 설계</h3>
<p>2국면 교차 설계를 시연하기 위해 hemp 패키지의 writing 데이터 세트를 사용합니다. 이 가상의 데이터 세트에는 두 명의 채점자(r)가 채점한 5개의 쓰기 프롬프트(w)에서 측정된 10명의 학생(들)에 대한 데이터가 포함되어 있습니다. 데이터는 각 행이 단일 관찰(즉, 단일 쓰기 프롬프트에 대한 점수)에 해당하는 긴 형식이며, 학생, 프롬프트, 채점자 및 점수 변수에는 학생 식별자, 쓰기 프롬프트 식별자, 평가자 식별자 및 단일 관찰에 대한 점수가 포함되어 있습니다.</p>
<section id="g-연구-1" class="level4" data-number="3.3.2.1">
<h4 data-number="3.3.2.1" class="anchored" data-anchor-id="g-연구-1"><span class="header-section-number">3.3.2.1</span> G 연구</h4>
<p>방정식 3.3과 그림 3.1은 2국면 교차(p x w x r ) 설계에서 추정되는 분산을 나타냅니다. 학생, 쓰기 프롬프트, 채점자 및 이들의 상호작용에 대한 분산이 추정됩니다. 위의 단일국면 설계와 달리 모든 이원 상호작용을 추정할 수 있으므로 lme4에 대한 호출에서 상호작용을 지정해야 합니다. 그러나 위에서 설명한 대로 학생-작성 프롬프트-채점자 간 상호작용은 잔차 분산 내에서 섞여있으므로 지정하지 않습니다. 상호작용을 나타내기 위해 lme4는 구문 (1 | variable1:variable2)을 사용합니다. 이 구문은 lm 호출에서 상호 작용을 지정하는 방식과 유사합니다. 아래의 lmer 함수 호출에서는 6개의 분산(즉, 학생, 프롬프트, 채점자, 프롬프트별 학생, 채점자별 학생, 프롬프트별 채점자)을 지정합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>twofacet_mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(scores <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> students) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> prompts) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> raters) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> students<span class="sc">:</span>prompts) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> students<span class="sc">:</span>raters) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> prompts<span class="sc">:</span>raters), <span class="at">data =</span> writing)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>그런 다음 twofacet_mod 개체를 gstudy 함수에 전달하여 G 연구에 대한 분산을 추정할 수 있도록 합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>twofacet <span class="ot">&lt;-</span> <span class="fu">gstudy</span>(twofacet_mod)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>twofacet</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            Source Est.Variance Percent.Variance
1 students:prompts      12.8891             3.6%
2  students:raters      62.4069            17.4%
3   prompts:raters       4.8775             1.4%
4         students     180.1812            50.2%
5          prompts       8.1506             2.3%
6           raters      19.8003             5.5%
7         Residual      70.3423            19.6%</code></pre>
</div>
</div>
<p>위의 출력에서는 상호작용이 먼저 나온 다음 학생, 쓰기 프롬프트, 채점자의 분산, 그리고 마지막으로 잔차 분산이 나옵니다. 가장 큰 분산 구성 요소인 학생의 분산(180.176)은 점수 총 분산의 약 50%를 차지합니다. 이는 전집 점수에 대한 분산 성분으로, 학생들이 작문 평가에서 체계적으로 점수에 차이가 있음을 나타냅니다. 채점자의 분산 성분은 학생에 비해 작지만 쓰기 프롬프트 분산보다는 큽니다. 이 분산의 제곱근(<span class="math inline">\(\sqrt{19.8028}\)</span> = 4.45)을 구하면 채점자 평균의 예상 범위는 약 18 또는 27입니다(정규 분포 및 표준 편차 2 또는 3 가정). 이 범위는 쓰기 프롬프트의 점수 범위(0~100점)에 비해 상당히 작습니다. 마찬가지로 쓰기 프롬프트의 분산은 더 작았으며 쓰기 프롬프트에서 예상되는 점수 범위는 12 또는 18로 매우 작았습니다. 학생별 쓰기 프롬프트와 채점자별 쓰기 프롬프트의 분산은 매우 작았는데, 이는 쓰기 프롬프트에 따라 학생의 순위가 크게 달라지지 않았으며 채점자가 문항을 합리적으로 일관되게 채점했음을 나타냅니다. 채점자별 학생 분산(62.4073)은 다른 분산 구성 요소에 비해 상당히 큽니다. 이 결과는 일부 채점자가 일부 학생에게 다른 학생보다 높은 점수를 부여했음을 시사합니다. 마지막으로, 잔차 분산(70.3428 또는 전체 분산의 약 20%)은 분산의 상당 부분이 학생, 채점자, 쓰기 프롬프트 간의 3원 상호작용 또는 연구에서 설명되지 않은 기타 무선 또는 체계적인 변산의 원인으로 인해 발생했음을 보여줍니다.</p>
</section>
<section id="d-연구-1" class="level4" data-number="3.3.2.2">
<h4 data-number="3.3.2.2" class="anchored" data-anchor-id="d-연구-1"><span class="header-section-number">3.3.2.2</span> D 연구</h4>
<p>채점자 2명과 쓰기 프롬프트 5개가 있는 2국면 교차 설계의 일반화 가능도 및 의존도 계수는 dstudy 함수를 사용하여 계산할 수 있습니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy</span>(twofacet, <span class="at">n =</span> <span class="fu">c</span>(<span class="st">"raters"</span> <span class="ot">=</span> <span class="dv">2</span>, <span class="st">"prompts"</span> <span class="ot">=</span> <span class="dv">5</span>), <span class="at">unit =</span> <span class="st">"students"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            Source Est.Variance   N Ratio of Var:N
1 students:prompts      12.8891   5        2.57782
2  students:raters      62.4069   2       31.20345
3   prompts:raters       4.8775  10        0.48775
4         students     180.1812 100      180.18120
5          prompts       8.1506   5        1.63012
6           raters      19.8003   2        9.90015
7         Residual      70.3423  10        7.03423

The generalizability coefficient is: 0.8153117.
The dependability coefficient is: 0.773261.</code></pre>
</div>
</div>
<p>일반화 가능도 계수는 0.82, 의존도 계수는 0.77입니다. 저부담 검사의 경우, 이 계수는 허용 가능한 수준입니다. 그러나 고부담 검사에서는 0.90 이상의 신뢰도가 바람직합니다.</p>
<p>작문 평가가 고부담 검사의 의사 결정에 사용된다고 가정하면, 어떤 종류의 설계가 0.90 이상의 일반화 가능도 계수를 제공할지 결정하기 위해 dstudy_plot 함수를 사용할 수 있습니다. 아래에서는 쓰기 프롬프트의 수(3~8개 범위)에 대한 일반화 가능도 계수를 채점자 수(1~5개 범위)로 플롯했습니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy_plot</span>(twofacet, <span class="at">unit =</span> <span class="st">"students"</span>, <span class="at">facets =</span> <span class="fu">list</span>(<span class="at">prompts =</span> <span class="dv">3</span><span class="sc">:</span><span class="dv">8</span>,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="at">raters =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="chap03_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>그림 3.5는 쓰기 프롬프트와 채점자에 의해 예상되는 일반화 가능도 계수를 보여줍니다. 신뢰도 0.90을 얻으려면 적어도 4명의 채점자가 필요합니다. 채점자가 4명인 경우 약 7개의 쓰기 프롬프트가 필요하고, 채점자가 5명인 경우 약 4개의 쓰기 프롬프트가 필요합니다. 어떤 설계를 사용할지 여부는 채점자의 가용성 또는 응시자가 응답하게 할 프롬프트의 수에 따라 달라질 수 있습니다. 또한 세 개 이상의 쓰기 프롬프트와 두 명의 채점자를 두어 신뢰도를 추가로 높일 가치가 있는지 여부를 결정할 수도 있습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_35.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">채점자 수에 따른 쓰기 프롬프트 수에 대한 일반화 가능도 계수</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="국면-부분-내재-설계" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="국면-부분-내재-설계"><span class="header-section-number">3.3.3</span> 2국면 부분 내재 설계</h3>
<p>부분적으로 내재된 2국면 설계를 보여주기 위해 hemp 패키지의 writing2 데이터 세트를 사용합니다. 이 가상 데이터 세트에는 두 명의 채점자(r)가 채점한 5개의 쓰기 프롬프트(w)에서 측정된 10명의 학생(s)에 대한 데이터가 포함되어 있습니다. 채점자가 모든 학생의 모든 쓰기 프롬프트에 점수를 매긴 writing 데이터 집합과 달리, writing2 데이터 집합에서는 각 채점자가 한 학생에게만 점수를 매겼습니다(즉, 채점자가 학생 내에 중첩되어 있음). 모든 학생에 대해 두 명의 채점자가 5개의 쓰기 프롬프트 모두에서 한 학생에게 점수를 매겼습니다. 그러나 각 채점자는 한 명 이하의 학생에게만 점수를 부여했습니다. 이 설계는 r:s X w 와 같이 표현할 수 있으며, 이는 채점자가 학생 내에 내재되어 있고 쓰기 프롬프트와 교차되어 있음을 나타냅니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig_36.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">2국면 부분 내재 설계의 벤 다이어그램, (r :s) x w. 여기서 s는 학생(측정 단위), w는 쓰기 프롬프트, r은 채점자, e는 오차임</figcaption><p></p>
</figure>
</div>
<section id="g-연구-2" class="level4" data-number="3.3.3.1">
<h4 data-number="3.3.3.1" class="anchored" data-anchor-id="g-연구-2"><span class="header-section-number">3.3.3.1</span> G 연구</h4>
<p>writing 데이터 집합과 마찬가지로 writing2 데이터도 각 행이 단일 관찰(즉, 단일 쓰기 프롬프트의 점수)에 해당하는 긴 형식입니다. 학생, 쓰기 프롬프트, 채점자 및 점수 변수에는 학생 식별자, 쓰기 프롬프트 식별자, 채점자 식별자 및 단일 관찰에 대한 점수가 포함됩니다.</p>
<p>그림 3.6은 이 설계의 변산원에 대한 벤 다이어그램을 보여줍니다. 부분 내재 설계에서는 채점자와 관련된 변산이 피험자 내에 완전히 내재되어 있으며 채점자 변산(r)은 피험자별 변산(sr)과 완전히 섞여 있습니다. 그림 3.6은 또한 채점자별 쓰기 프롬프트 변산(wr)이 학생별, 채점자별 쓰기 프롬프트 변산(swr) 및 잔차 분산(e)과 완전히 혼재되어 있음을 보여줍니다. 쓰기 프롬프트 변산(w)과 학생별 쓰기 프롬프트 변산(wr)을 추정할 수 있습니다.</p>
<p>lmer를 사용하여 내재 설계를 맞추는 것은 교차 설계와 비슷하지만, 채점자가 학생에 내재되도록 지정해야 합니다. 채점자가 학생에 내재되도록 지정하는 구문은 (1 | students/raters)입니다. 이렇게 하면 섞여있는 학생 변산과 채점자 및 채점자별 학생 변산과 관련된 변산을 추정할 수 있습니다. lmer 함수를 호출할 때 쓰기 프롬프트 변산(1 | prompts)과 학생별 쓰기 프롬프트 변산(1 | students:prompts)도 지정해야 합니다. 이 내재 모델의 결과를 nested_model로 저장한 다음 gstudy 함수에서 사용합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>nested_model <span class="ot">&lt;-</span> <span class="fu">lmer</span>(scores <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> students<span class="sc">/</span>raters) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> prompts) <span class="sc">+</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="sc">|</span> students<span class="sc">:</span>prompts), <span class="at">data =</span> writing2)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>nested <span class="ot">&lt;-</span> <span class="fu">gstudy</span>(nested_model)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>nested</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            Source Est.Variance Percent.Variance
1 students:prompts      10.4498               3%
2  raters:students      82.2099            23.6%
3         students     170.2747            48.8%
4          prompts      10.5903               3%
5         Residual      75.2199            21.6%</code></pre>
</div>
</div>
<p>G 연구 결과에는 학생별 쓰기 프롬프트 분산(학생:프롬프트), 학생별 채점자 분산(평가자:학생), 학생(즉, 전집 점수) 분산(학생), 쓰기 프롬프트 분산(프롬프트), 마지막으로 학생별 쓰기 프롬프트별 채점자 분산과 쓰기 프롬프트별 채점자 분산이 포함된 잔차(잔차)가 출력됩니다.</p>
<p>가장 큰 변산원은 학생으로 전체 변산의 거의 50%를 차지하며, 그 다음으로는 채점자별 학생 변산(24%), 마지막으로 잔차 변산 및 기타 혼재된 변산원이 그 뒤를 잇습니다.</p>
</section>
<section id="d-연구-2" class="level4" data-number="3.3.3.2">
<h4 data-number="3.3.3.2" class="anchored" data-anchor-id="d-연구-2"><span class="header-section-number">3.3.3.2</span> D 연구</h4>
<p>내재 설계는 dstudy 함수를 사용하여 교차 설계와 정확히 동일한 방식으로 지정됩니다. 채점자 2명과 프롬프트 5개가 있는 D 연구는 아래와 같이 지정됩니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy</span>(nested, <span class="at">n =</span> <span class="fu">c</span>(<span class="st">"raters"</span> <span class="ot">=</span> <span class="dv">2</span>, <span class="st">"prompts"</span> <span class="ot">=</span> <span class="dv">5</span>), <span class="at">unit =</span> <span class="st">"students"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            Source Est.Variance   N Ratio of Var:N
1 students:prompts      10.4498   5        2.08996
2  raters:students      82.2099   2       41.10495
3         students     170.2747 100      170.27470
4          prompts      10.5903   5        2.11806
5         Residual      75.2199  10        7.52199

The generalizability coefficient is: 0.770503.
The dependability coefficient is: 0.7631884.</code></pre>
</div>
</div>
<p>이 설계를 사용하면 상대적 의사 결정(0.77)과 절대적 의사 결정(0.76)에 대한 신뢰도가 상당히 높습니다. 여러 설계를 비교하려면 다시 dstudy_plot 함수를 사용할 수 있습니다.</p>
</section>
</section>
<section id="고정-국면을-가진-2국면-교차-설계" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="고정-국면을-가진-2국면-교차-설계"><span class="header-section-number">3.3.4</span> 고정 국면을 가진 2국면 교차 설계</h3>
<p>마지막 예로, 다시 writing 데이터 세트를 고려해 보겠습니다. 하지만 이번에는 쓰기 프롬프트를 고정된 국면으로 취급하겠습니다. 즉, 쓰기 프롬프트에 대한 일반화에 관심이 있는 것이 아니라 동일한 쓰기 프롬프트에 대해 서로 다른 채점자가 어떻게 점수를 매기는지 알고자 하는 것입니다. 이는 일반화 범위의 제한을 나타내며 추정되는 분산과 그에 따른 신뢰도 추정치에 영향을 미칩니다. 채점자를 무선으로 처리하고 쓰기 프롬프트를 고정된 것으로 간주하므로 결과 모델은 분산 분석 프레임워크에서 혼합 모형이 됩니다.</p>
<section id="g-연구-3" class="level4" data-number="3.3.4.1">
<h4 data-number="3.3.4.1" class="anchored" data-anchor-id="g-연구-3"><span class="header-section-number">3.3.4.1</span> G 연구</h4>
<p>이전 예제에서는 writing 데이터 세트에 두 개의 국면이 교차하는 설계를 적용하고 이를 twofacet_mod로 저장했습니다. 이번에는 쓰기 프롬프트를 고정 국면으로 처리하고 싶다는 것을 gstudy 함수에 알려야 합니다. 이를 위해 gstudy 함수에 fixed = “prompts”를 포함시키고 결과를 twofacet_fixed로 저장합니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>twofacet_fixed <span class="ot">&lt;-</span> <span class="fu">gstudy</span>(twofacet_mod, <span class="at">fixed =</span> <span class="st">"prompts"</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>twofacet_fixed</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Source Est.Variance Percent.Variance
1   raters      20.7758             7.4%
2 students     182.7590            65.3%
3 Residual      76.4754            27.3%</code></pre>
</div>
</div>
<p>쓰기 프롬프트와 관련된 변산원이 이러한 변산원 내에 포함되기 때문에 출력에는 완전히 교차된 2국면 설계의 변산보다 적은 수의 변산원이 포함됩니다. 쓰기 프롬프트가 고정된 국면인 경우에는 표시되지 않지만, 학생별 쓰기 프롬프트 변산이 학생 변산(전집 점수 변산)에 기여하므로 이 변산 성분이 2국면이 무선인 2국면 설계의 변산 성분보다 더 큰 이유입니다. 이 때문에 이 특정 설계에서는 신뢰도가 더 높습니다.</p>
</section>
<section id="d-연구-3" class="level4" data-number="3.3.4.2">
<h4 data-number="3.3.4.2" class="anchored" data-anchor-id="d-연구-3"><span class="header-section-number">3.3.4.2</span> D 연구</h4>
<p>고정 국면을 가진 설계가 더 높은 신뢰도를 갖는 경향이 있음을 보여주기 위해 앞서 사용한 것과 동일한 D 연구에 2명의 채점자와 5개의 쓰기 프롬프트를 적용했습니다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dstudy</span>(twofacet_fixed, <span class="at">n =</span> <span class="fu">c</span>(<span class="st">"raters"</span> <span class="ot">=</span> <span class="dv">2</span>, <span class="st">"prompts"</span> <span class="ot">=</span> <span class="dv">5</span>), <span class="at">unit =</span> <span class="st">"students"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Source Est.Variance   N Ratio of Var:N
1   raters      20.7758   2       10.38790
2 students     182.7590 100      182.75900
3 Residual      76.4754  10        7.64754

The generalizability coefficient is: 0.9598357.
The dependability coefficient is: 0.9101796.</code></pre>
</div>
</div>
<p>쓰기 프롬프트가 고정된 경우 일반화 가능도 계수는 0.96으로 무선으로 처리된 경우의 0.82에 비해 높았습니다. 이는 국면이 무작위인지 고정인지 고려하는 것의 중요성과 이러한 결정이 신뢰도에 미치는 결과를 강조합니다.</p>
</section>
</section>
</section>
<section id="요약" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="요약"><span class="header-section-number">3.4</span> 요약</h2>
<p>이 장에서는 G 이론을 소개했습니다. 다양한 설계과 이러한 특정 설계에 대한 G 및 D 연구를 실행하는 방법을 제시했습니다. G 이론에서 더 복잡한 설계를 사용하고자 하는 독자에게는 gtheory 패키지를 추천합니다(Moore, 2016). gtheory 패키지는 단변량 및 다변량 모델 모두에 적합할 수 있는 반면, hemp의 G 이론 함수는 단변량 모델에만 적합할 수 있습니다. 다음 장에서는 요인 분석에 대해 알아보겠습니다. 요인 분석은 이 교재에서 중요한 전환을 의미합니다. 지금까지 제시된 모델은 (관찰된) 검사 점수에 초점을 맞춘 반면, 요인 분석은 개별 문항에 초점을 맞춥니다. 요인 분석은 또한 제5장에서 소개할 문항 반응 이론의 기초를 형성합니다.</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>이것은 급내상관계수 ICC(intraclass correlations)로 알려져 있습니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./chap02.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">고전검사이론</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./chap04.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">측정에서 요인분석적 접근</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>